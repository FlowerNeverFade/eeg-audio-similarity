#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Permutation test for RSA significance testing.

This module provides GPU-accelerated permutation tests for computing
p-values of RSA correlations.
"""

import torch

# Global device configuration
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')


def gpu_rankdata_average(x, device=None):
    """Compute ranks with average tie handling on GPU."""
    if device is None:
        device = DEVICE
    
    x = torch.as_tensor(x, dtype=torch.float32, device=device)
    n = x.shape[0]
    
    if n == 0:
        return torch.empty(0, device=device, dtype=torch.float32)
    
    vals, idx_sorted = torch.sort(x)
    base_ranks = torch.arange(1, n + 1, dtype=torch.float32, device=device)
    
    neq = torch.ones(n, dtype=torch.bool, device=device)
    neq[1:] = vals[1:] != vals[:-1]
    group_ids = torch.cumsum(neq.long(), dim=0) - 1
    
    ones = torch.ones(n, dtype=torch.float32, device=device)
    group_counts = torch.zeros(n, dtype=torch.float32, device=device)
    group_counts.scatter_add_(0, group_ids, ones)
    
    group_rank_sums = torch.zeros(n, dtype=torch.float32, device=device)
    group_rank_sums.scatter_add_(0, group_ids, base_ranks)
    
    group_avg_ranks = group_rank_sums / group_counts.clamp(min=1.0)
    avg_ranks_sorted = group_avg_ranks[group_ids]
    
    ranks = torch.empty(n, dtype=torch.float32, device=device)
    ranks[idx_sorted] = avg_ranks_sorted
    
    return ranks


def compute_rdm_vec(X, device=None):
    """Compute RDM vector using correlation distance."""
    if device is None:
        device = DEVICE
    
    X_t = torch.as_tensor(X, dtype=torch.float32, device=device)
    
    if X_t.shape[0] < 2:
        return torch.empty(0, device=device)
    
    Xc = X_t - X_t.mean(dim=1, keepdim=True)
    norms = torch.linalg.norm(Xc, dim=1, keepdim=True) + 1e-12
    Xn = Xc / norms
    corr = Xn @ Xn.T
    rdm = 1.0 - corr
    
    idx = torch.triu_indices(rdm.shape[0], rdm.shape[0], offset=1, device=device)
    return rdm[idx[0], idx[1]]


def permutation_pvalue(eeg_features, audio_features, observed_rsa, 
                       permutations=500, batch_size=8192, device=None):
    """
    Compute permutation p-value for RSA significance.
    
    The null distribution is generated by shuffling the time labels
    of the audio features and recomputing the RSA correlation.
    
    Args:
        eeg_features: torch.Tensor of shape (T, D_eeg) - EEG features
        audio_features: torch.Tensor of shape (T, D_audio) - Audio features
        observed_rsa: float - observed RSA (Spearman) correlation
        permutations: int - number of permutations (default: 500)
        batch_size: int - batch size for GPU computation
        device: torch.device, optional
    
    Returns:
        float: p-value (proportion of permuted correlations >= observed)
    
    Example:
        >>> eeg = torch.randn(100, 50)
        >>> audio = torch.randn(100, 20)
        >>> observed = 0.3  # Observed RSA
        >>> pval = permutation_pvalue(eeg, audio, observed)
    """
    if device is None:
        device = DEVICE
    
    eeg_t = torch.as_tensor(eeg_features, dtype=torch.float32, device=device)
    audio_t = torch.as_tensor(audio_features, dtype=torch.float32, device=device)
    
    n = eeg_t.shape[0]
    if n < 2:
        return 1.0
    
    # Compute EEG RDM (fixed)
    rdm_eeg = compute_rdm_vec(eeg_t, device)
    rank_eeg = gpu_rankdata_average(rdm_eeg, device)
    rank_eeg_centered = rank_eeg - rank_eeg.mean()
    denom_rank_eeg = torch.sqrt((rank_eeg_centered ** 2).sum()) + 1e-12
    
    # Compute audio RDM and rank matrix for fast lookup
    rdm_audio_full = torch.zeros((n, n), dtype=torch.float32, device=device)
    audio_rdm_vec = compute_rdm_vec(audio_t, device)
    rank_audio_vec = gpu_rankdata_average(audio_rdm_vec, device)
    
    tri_i, tri_j = torch.triu_indices(n, n, offset=1, device=device)
    rdm_audio_full[tri_i, tri_j] = rank_audio_vec
    rdm_audio_full[tri_j, tri_i] = rank_audio_vec
    
    # Generate all permutations
    perms_all = torch.stack([torch.randperm(n, device=device) for _ in range(permutations)])
    
    count_ge = 0
    idx = 0
    
    while idx < permutations:
        bsz = min(batch_size, permutations - idx)
        perms = perms_all[idx:idx + bsz]
        
        # Get permuted RDM vectors using indexing
        pairs0 = perms[:, tri_i]
        pairs1 = perms[:, tri_j]
        vects_rank = rdm_audio_full[pairs0, pairs1]
        
        # Compute Spearman correlation for each permutation
        vects_rank_centered = vects_rank - vects_rank.mean(dim=1, keepdim=True)
        denom_vects = torch.sqrt((vects_rank_centered ** 2).sum(dim=1)) + 1e-12
        corrs = (vects_rank_centered * rank_eeg_centered).sum(dim=1) / (denom_rank_eeg * denom_vects)
        
        count_ge += int((corrs >= observed_rsa).sum().item())
        idx += bsz
    
    pval = (count_ge + 1) / (permutations + 1)
    return float(pval)


def permutation_test_rsa(rdm1, rdm2, permutations=500, device=None):
    """
    Permutation test directly on RDM vectors.
    
    Args:
        rdm1: torch.Tensor - first RDM vector
        rdm2: torch.Tensor - second RDM vector
        permutations: int - number of permutations
        device: torch.device, optional
    
    Returns:
        tuple: (observed_rsa, p_value)
    """
    if device is None:
        device = DEVICE
    
    t1 = torch.as_tensor(rdm1, dtype=torch.float32, device=device)
    t2 = torch.as_tensor(rdm2, dtype=torch.float32, device=device)
    
    if t1.numel() == 0 or t2.numel() == 0:
        return 0.0, 1.0
    
    # Observed Spearman
    rank1 = gpu_rankdata_average(t1, device)
    rank2 = gpu_rankdata_average(t2, device)
    
    r1c = rank1 - rank1.mean()
    r2c = rank2 - rank2.mean()
    denom = torch.sqrt((r1c ** 2).sum() * (r2c ** 2).sum()) + 1e-12
    observed = float(((r1c * r2c).sum() / denom).item())
    
    # Permutation test
    count_ge = 0
    for _ in range(permutations):
        perm = torch.randperm(t2.shape[0], device=device)
        t2_perm = t2[perm]
        rank2_perm = gpu_rankdata_average(t2_perm, device)
        r2c_perm = rank2_perm - rank2_perm.mean()
        denom_perm = torch.sqrt((r1c ** 2).sum() * (r2c_perm ** 2).sum()) + 1e-12
        r_perm = float(((r1c * r2c_perm).sum() / denom_perm).item())
        if r_perm >= observed:
            count_ge += 1
    
    pval = (count_ge + 1) / (permutations + 1)
    return observed, pval


if __name__ == "__main__":
    # Test the functions
    eeg = torch.randn(100, 50)
    audio = eeg[:, :20] + 0.5 * torch.randn(100, 20)  # Correlated
    
    # Compute observed RSA
    rdm_eeg = compute_rdm_vec(eeg)
    rdm_audio = compute_rdm_vec(audio)
    
    observed, pval = permutation_test_rsa(rdm_eeg, rdm_audio, permutations=100)
    print(f"Observed RSA: {observed:.4f}, p-value: {pval:.4f}")

